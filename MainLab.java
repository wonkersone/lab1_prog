package ru.itmo;

import java.util.Random;


public class MainLab {
    public static final String COLORS[] = {"\u001B[31m", "\u001B[33m", "\u001B[32m",
            "\u001B[36m", "\u001B[34m", "\u001B[35m", "\u001B[31m", "\u001B[33m", "\u001B[32m",
            "\u001B[36m", "\u001B[34m", "\u001B[35m", "\u001B[31m", "\u001B[33m", "\u001B[32m"};
    public static void main(String[] args) {
        long[] z = new long[12];
        for (int i = 15; i >= 4; i--) {                             //Создать одномерный массив z типа long. Заполнить его числами от 4 до 15 включительно в порядке убывания.
            z[15 - i] = i;
        }

        float[] x = new float[16];                                  //Создать одномерный массив x типа float.

        Random random = new Random();
        for (int i = 0; i < x.length; i++) {                        //Заполнить его 16-ю случайными числами в диапазоне от -13.0 до 12.0.
            x[i] = random.nextInt((11 - (-13)) + 1) + (-13); //указываем границы рандомайзера по формуле ((max - min) + 1) + min
            if (x[i] != -13 && x[i] != 12) {                        //Если сгенерилась одна из границ отрезка, то пропускаем ее в массив
                float dr = random.nextFloat(1);              //Если нет, то генерируем дробную часть от 0 до 1
                x[i] += dr;                                         //и прибавляем к основному числу //
            }
        }

        float[][] w = new float[12][16];                            //Создать двумерный массив w размером 12x16.

        for (int i = 0; i < 12; i++) {
            for (int j = 0; j < 16; j++) {
                if (z[i] == 7) {                                    // Если z[i] = 7, выполняем п. 3.1
                    w[i][j] = 2 * (float) Math.tan(Math.sin(x[j]));
                }
                // Если z[i] есть в массиве {4, 5, 6, 8, 9, 11}, то выполняет п. 3.2
                else if (z[i] == 4 || z[i] == 5 || z[i] == 6 || z[i] == 8 || z[i] == 9 || z[i] == 11) {
                    w[i][j] = (float) Math.cbrt(Math.pow(((Math.pow(Math.E, x[j]) - 0.5) / (0.25)), Math.tan(x[j]))); // округляем число до 2 знаков после запятой
                }
                // В остальных случая выполняем п. 3.3
                else w[i][j] = (float) Math.pow(((1./2) / Math.pow(Math.E, Math.sin(Math.cos(x[j])))), 3); // округляем число до 2 знаков после запятой


            }
        }
        int maxLen = 7;                             //для ровного вывода матрицы найдем длину самого длинного элемента в ней
        String format;                              //создаем строку format, которая будет задавать формат вывода
        int temp;

        for (int i = 0; i < w.length; i++) {        //ищем длину самого длинного элемента
            for (int j = 0; j < w[i].length; j++) {
                temp = String.valueOf((int) w[i][j]).length() + 5;  //нам нужна длина целой части, тк длина дробной везде одинаковая
                if (temp > maxLen) {                                //минимальная длина целой части = 1, поэтому на случай если все элементы матрицы будут с 1 цифрой до запятой, прибавляем к этому значению 5, чтоб сохранить ровный вывод
                    maxLen = temp;
                }
            }
        }

        format = "%" + maxLen + ".2f";    //делаем строку для форматирования вывода пригодной для использования
        for (int i = 0; i < 12; i++) {
            for (int j = 0; j < 16; j++) {
                System.out.printf(format, w[i][j]);     //выводим первую строку элементов матрицы
            }
            System.out.println();
        }

    }
}
